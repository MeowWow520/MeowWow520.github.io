{"title":"","type":"page","uid":"1cd19fc71517798e2fa5b7457d1fb06e","text":"import logger from '../logger.js'; class L2DBaseModel { constructor() { this.live2DModel = null; this.modelMatrix = null; this.eyeBlink = nu...","date":"2025-11-18T04:43:50.316Z","updated":"2025-11-18T04:43:50.316Z","comments":true,"path":"api/pages/live2d-widget/build/cubism2/Live2DFramework.js","covers":null,"content":"import logger from '../logger.js';\nclass L2DBaseModel {\n    constructor() {\n        this.live2DModel = null;\n        this.modelMatrix = null;\n        this.eyeBlink = null;\n        this.physics = null;\n        this.pose = null;\n        this.initialized = false;\n        this.updating = false;\n        this.alpha = 1;\n        this.accAlpha = 0;\n        this.lipSync = false;\n        this.lipSyncValue = 0;\n        this.accelX = 0;\n        this.accelY = 0;\n        this.accelZ = 0;\n        this.dragX = 0;\n        this.dragY = 0;\n        this.startTimeMSec = null;\n        this.mainMotionManager = new L2DMotionManager();\n        this.expressionManager = new L2DMotionManager();\n        this.motions = {};\n        this.expressions = {};\n        this.isTexLoaded = false;\n    }\n    getModelMatrix() {\n        return this.modelMatrix;\n    }\n    setAlpha(a) {\n        if (a > 0.999)\n            a = 1;\n        if (a < 0.001)\n            a = 0;\n        this.alpha = a;\n    }\n    getAlpha() {\n        return this.alpha;\n    }\n    isInitialized() {\n        return this.initialized;\n    }\n    setInitialized(v) {\n        this.initialized = v;\n    }\n    isUpdating() {\n        return this.updating;\n    }\n    setUpdating(v) {\n        this.updating = v;\n    }\n    getLive2DModel() {\n        return this.live2DModel;\n    }\n    setLipSync(v) {\n        this.lipSync = v;\n    }\n    setLipSyncValue(v) {\n        this.lipSyncValue = v;\n    }\n    setAccel(x, y, z) {\n        this.accelX = x;\n        this.accelY = y;\n        this.accelZ = z;\n    }\n    setDrag(x, y) {\n        this.dragX = x;\n        this.dragY = y;\n    }\n    getMainMotionManager() {\n        return this.mainMotionManager;\n    }\n    getExpressionManager() {\n        return this.expressionManager;\n    }\n    loadModelData(path, callback) {\n        const pm = Live2DFramework.getPlatformManager();\n        logger.info('Load model : ' + path);\n        pm.loadLive2DModel(path, (l2dModel) => {\n            this.live2DModel = l2dModel;\n            this.live2DModel.saveParam();\n            const _err = Live2D.getError();\n            if (_err != 0) {\n                logger.error('Error : Failed to loadModelData().');\n                return;\n            }\n            this.modelMatrix = new L2DModelMatrix(this.live2DModel.getCanvasWidth(), this.live2DModel.getCanvasHeight());\n            this.modelMatrix.setWidth(2);\n            this.modelMatrix.setCenterPosition(0, 0);\n            callback(this.live2DModel);\n        });\n    }\n    loadTexture(no, path, callback) {\n        texCounter++;\n        const pm = Live2DFramework.getPlatformManager();\n        logger.info('Load Texture : ' + path);\n        pm.loadTexture(this.live2DModel, no, path, () => {\n            texCounter--;\n            if (texCounter == 0)\n                this.isTexLoaded = true;\n            if (typeof callback == 'function')\n                callback();\n        });\n    }\n    loadMotion(name, path, callback) {\n        const pm = Live2DFramework.getPlatformManager();\n        logger.trace('Load Motion : ' + path);\n        let motion = null;\n        pm.loadBytes(path, (buf) => {\n            motion = Live2DMotion.loadMotion(buf);\n            if (name != null) {\n                this.motions[name] = motion;\n            }\n            callback(motion);\n        });\n    }\n    loadExpression(name, path, callback) {\n        const pm = Live2DFramework.getPlatformManager();\n        logger.trace('Load Expression : ' + path);\n        pm.loadBytes(path, (buf) => {\n            if (name != null) {\n                this.expressions[name] = L2DExpressionMotion.loadJson(buf);\n            }\n            if (typeof callback == 'function')\n                callback();\n        });\n    }\n    loadPose(path, callback) {\n        const pm = Live2DFramework.getPlatformManager();\n        logger.trace('Load Pose : ' + path);\n        try {\n            pm.loadBytes(path, (buf) => {\n                this.pose = L2DPose.load(buf);\n                if (typeof callback == 'function')\n                    callback();\n            });\n        }\n        catch (e) {\n            logger.warn(e);\n        }\n    }\n    loadPhysics(path) {\n        const pm = Live2DFramework.getPlatformManager();\n        logger.trace('Load Physics : ' + path);\n        try {\n            pm.loadBytes(path, (buf) => {\n                this.physics = L2DPhysics.load(buf);\n            });\n        }\n        catch (e) {\n            logger.warn(e);\n        }\n    }\n    hitTestSimple(drawID, testX, testY) {\n        const drawIndex = this.live2DModel.getDrawDataIndex(drawID);\n        if (drawIndex < 0)\n            return false;\n        const points = this.live2DModel.getTransformedPoints(drawIndex);\n        let left = this.live2DModel.getCanvasWidth();\n        let right = 0;\n        let top = this.live2DModel.getCanvasHeight();\n        let bottom = 0;\n        for (let j = 0; j < points.length; j = j + 2) {\n            const x = points[j];\n            const y = points[j + 1];\n            if (x < left)\n                left = x;\n            if (x > right)\n                right = x;\n            if (y < top)\n                top = y;\n            if (y > bottom)\n                bottom = y;\n        }\n        const tx = this.modelMatrix.invertTransformX(testX);\n        const ty = this.modelMatrix.invertTransformY(testY);\n        return left <= tx && tx <= right && top <= ty && ty <= bottom;\n    }\n}\nlet texCounter = 0;\nclass L2DExpressionMotion extends AMotion {\n    constructor() {\n        super();\n        this.paramList = [];\n    }\n    static loadJson(buf) {\n        const ret = new L2DExpressionMotion();\n        const pm = Live2DFramework.getPlatformManager();\n        const json = pm.jsonParseFromBytes(buf);\n        ret.setFadeIn(parseInt(json.fade_in) > 0 ? parseInt(json.fade_in) : 1000);\n        ret.setFadeOut(parseInt(json.fade_out) > 0 ? parseInt(json.fade_out) : 1000);\n        if (json.params == null) {\n            return ret;\n        }\n        const params = json.params;\n        const paramNum = params.length;\n        ret.paramList = [];\n        for (let i = 0; i < paramNum; i++) {\n            const param = params[i];\n            const paramID = param.id.toString();\n            let value = parseFloat(param.val);\n            let calcTypeInt = L2DExpressionMotion.TYPE_ADD;\n            const calc = param.calc != null ? param.calc.toString() : 'add';\n            if (calc === 'add') {\n                calcTypeInt = L2DExpressionMotion.TYPE_ADD;\n            }\n            else if (calc === 'mult') {\n                calcTypeInt = L2DExpressionMotion.TYPE_MULT;\n            }\n            else if (calc === 'set') {\n                calcTypeInt = L2DExpressionMotion.TYPE_SET;\n            }\n            else {\n                calcTypeInt = L2DExpressionMotion.TYPE_ADD;\n            }\n            if (calcTypeInt == L2DExpressionMotion.TYPE_ADD) {\n                let defaultValue = param.def == null ? 0 : parseFloat(param.def);\n                value = value - defaultValue;\n            }\n            else if (calcTypeInt == L2DExpressionMotion.TYPE_MULT) {\n                let defaultValue = param.def == null ? 1 : parseFloat(param.def);\n                if (defaultValue == 0)\n                    defaultValue = 1;\n                value = value / defaultValue;\n            }\n            const item = new L2DExpressionParam();\n            item.id = paramID;\n            item.type = calcTypeInt;\n            item.value = value;\n            ret.paramList.push(item);\n        }\n        return ret;\n    }\n    updateParamExe(model, timeMSec, weight, motionQueueEnt) {\n        for (let i = this.paramList.length - 1; i >= 0; --i) {\n            const param = this.paramList[i];\n            if (param.type == L2DExpressionMotion.TYPE_ADD) {\n                model.addToParamFloat(param.id, param.value, weight);\n            }\n            else if (param.type == L2DExpressionMotion.TYPE_MULT) {\n                model.multParamFloat(param.id, param.value, weight);\n            }\n            else if (param.type == L2DExpressionMotion.TYPE_SET) {\n                model.setParamFloat(param.id, param.value, weight);\n            }\n        }\n    }\n}\nL2DExpressionMotion.EXPRESSION_DEFAULT = 'DEFAULT';\nL2DExpressionMotion.TYPE_SET = 0;\nL2DExpressionMotion.TYPE_ADD = 1;\nL2DExpressionMotion.TYPE_MULT = 2;\nfunction L2DExpressionParam() {\n    this.id = '';\n    this.type = -1;\n    this.value = null;\n}\nclass L2DEyeBlink {\n    constructor() {\n        this.nextBlinkTime = null;\n        this.stateStartTime = null;\n        this.blinkIntervalMsec = null;\n        this.eyeState = EYE_STATE.STATE_FIRST;\n        this.blinkIntervalMsec = 4000;\n        this.closingMotionMsec = 100;\n        this.closedMotionMsec = 50;\n        this.openingMotionMsec = 150;\n        this.closeIfZero = true;\n        this.eyeID_L = 'PARAM_EYE_L_OPEN';\n        this.eyeID_R = 'PARAM_EYE_R_OPEN';\n    }\n    calcNextBlink() {\n        const time = UtSystem.getUserTimeMSec();\n        const r = Math.random();\n        return time + r * (2 * this.blinkIntervalMsec - 1);\n    }\n    setInterval(blinkIntervalMsec) {\n        this.blinkIntervalMsec = blinkIntervalMsec;\n    }\n    setEyeMotion(closingMotionMsec, closedMotionMsec, openingMotionMsec) {\n        this.closingMotionMsec = closingMotionMsec;\n        this.closedMotionMsec = closedMotionMsec;\n        this.openingMotionMsec = openingMotionMsec;\n    }\n    updateParam(model) {\n        const time = UtSystem.getUserTimeMSec();\n        let eyeParamValue;\n        let t = 0;\n        switch (this.eyeState) {\n            case EYE_STATE.STATE_CLOSING:\n                t = (time - this.stateStartTime) / this.closingMotionMsec;\n                if (t >= 1) {\n                    t = 1;\n                    this.eyeState = EYE_STATE.STATE_CLOSED;\n                    this.stateStartTime = time;\n                }\n                eyeParamValue = 1 - t;\n                break;\n            case EYE_STATE.STATE_CLOSED:\n                t = (time - this.stateStartTime) / this.closedMotionMsec;\n                if (t >= 1) {\n                    this.eyeState = EYE_STATE.STATE_OPENING;\n                    this.stateStartTime = time;\n                }\n                eyeParamValue = 0;\n                break;\n            case EYE_STATE.STATE_OPENING:\n                t = (time - this.stateStartTime) / this.openingMotionMsec;\n                if (t >= 1) {\n                    t = 1;\n                    this.eyeState = EYE_STATE.STATE_INTERVAL;\n                    this.nextBlinkTime = this.calcNextBlink();\n                }\n                eyeParamValue = t;\n                break;\n            case EYE_STATE.STATE_INTERVAL:\n                if (this.nextBlinkTime < time) {\n                    this.eyeState = EYE_STATE.STATE_CLOSING;\n                    this.stateStartTime = time;\n                }\n                eyeParamValue = 1;\n                break;\n            case EYE_STATE.STATE_FIRST:\n            default:\n                this.eyeState = EYE_STATE.STATE_INTERVAL;\n                this.nextBlinkTime = this.calcNextBlink();\n                eyeParamValue = 1;\n                break;\n        }\n        if (!this.closeIfZero)\n            eyeParamValue = -eyeParamValue;\n        model.setParamFloat(this.eyeID_L, eyeParamValue);\n        model.setParamFloat(this.eyeID_R, eyeParamValue);\n    }\n}\nconst EYE_STATE = () => { };\nEYE_STATE.STATE_FIRST = 'STATE_FIRST';\nEYE_STATE.STATE_INTERVAL = 'STATE_INTERVAL';\nEYE_STATE.STATE_CLOSING = 'STATE_CLOSING';\nEYE_STATE.STATE_CLOSED = 'STATE_CLOSED';\nEYE_STATE.STATE_OPENING = 'STATE_OPENING';\nclass L2DMatrix44 {\n    constructor() {\n        this.tr = new Float32Array(16);\n        this.identity();\n    }\n    static mul(a, b, dst) {\n        const c = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        const n = 4;\n        let i, j, k;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                for (k = 0; k < n; k++) {\n                    c[i + j * 4] += a[i + k * 4] * b[k + j * 4];\n                }\n            }\n        }\n        for (i = 0; i < 16; i++) {\n            dst[i] = c[i];\n        }\n    }\n    identity() {\n        for (let i = 0; i < 16; i++)\n            this.tr[i] = i % 5 == 0 ? 1 : 0;\n    }\n    getArray() {\n        return this.tr;\n    }\n    getCopyMatrix() {\n        return new Float32Array(this.tr);\n    }\n    setMatrix(tr) {\n        if (this.tr == null || this.tr.length != this.tr.length)\n            return;\n        for (let i = 0; i < 16; i++)\n            this.tr[i] = tr[i];\n    }\n    getScaleX() {\n        return this.tr[0];\n    }\n    getScaleY() {\n        return this.tr[5];\n    }\n    transformX(src) {\n        return this.tr[0] * src + this.tr[12];\n    }\n    transformY(src) {\n        return this.tr[5] * src + this.tr[13];\n    }\n    invertTransformX(src) {\n        return (src - this.tr[12]) / this.tr[0];\n    }\n    invertTransformY(src) {\n        return (src - this.tr[13]) / this.tr[5];\n    }\n    multTranslate(shiftX, shiftY) {\n        const tr1 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, shiftX, shiftY, 0, 1];\n        L2DMatrix44.mul(tr1, this.tr, this.tr);\n    }\n    translate(x, y) {\n        this.tr[12] = x;\n        this.tr[13] = y;\n    }\n    translateX(x) {\n        this.tr[12] = x;\n    }\n    translateY(y) {\n        this.tr[13] = y;\n    }\n    multScale(scaleX, scaleY) {\n        const tr1 = [scaleX, 0, 0, 0, 0, scaleY, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n        L2DMatrix44.mul(tr1, this.tr, this.tr);\n    }\n    scale(scaleX, scaleY) {\n        this.tr[0] = scaleX;\n        this.tr[5] = scaleY;\n    }\n}\nclass L2DModelMatrix extends L2DMatrix44 {\n    constructor(w, h) {\n        super();\n        this.width = w;\n        this.height = h;\n    }\n    setPosition(x, y) {\n        this.translate(x, y);\n    }\n    setCenterPosition(x, y) {\n        const w = this.width * this.getScaleX();\n        const h = this.height * this.getScaleY();\n        this.translate(x - w / 2, y - h / 2);\n    }\n    top(y) {\n        this.setY(y);\n    }\n    bottom(y) {\n        const h = this.height * this.getScaleY();\n        this.translateY(y - h);\n    }\n    left(x) {\n        this.setX(x);\n    }\n    right(x) {\n        const w = this.width * this.getScaleX();\n        this.translateX(x - w);\n    }\n    centerX(x) {\n        const w = this.width * this.getScaleX();\n        this.translateX(x - w / 2);\n    }\n    centerY(y) {\n        const h = this.height * this.getScaleY();\n        this.translateY(y - h / 2);\n    }\n    setX(x) {\n        this.translateX(x);\n    }\n    setY(y) {\n        this.translateY(y);\n    }\n    setHeight(h) {\n        const scaleX = h / this.height;\n        const scaleY = -scaleX;\n        this.scale(scaleX, scaleY);\n    }\n    setWidth(w) {\n        const scaleX = w / this.width;\n        const scaleY = -scaleX;\n        this.scale(scaleX, scaleY);\n    }\n}\nclass L2DMotionManager extends MotionQueueManager {\n    constructor() {\n        super();\n        this.currentPriority = null;\n        this.reservePriority = null;\n        this.super = MotionQueueManager.prototype;\n    }\n    getCurrentPriority() {\n        return this.currentPriority;\n    }\n    getReservePriority() {\n        return this.reservePriority;\n    }\n    reserveMotion(priority) {\n        if (this.reservePriority >= priority) {\n            return false;\n        }\n        if (this.currentPriority >= priority) {\n            return false;\n        }\n        this.reservePriority = priority;\n        return true;\n    }\n    setReservePriority(val) {\n        this.reservePriority = val;\n    }\n    updateParam(model) {\n        const updated = MotionQueueManager.prototype.updateParam.call(this, model);\n        if (this.isFinished()) {\n            this.currentPriority = 0;\n        }\n        return updated;\n    }\n    startMotionPrio(motion, priority) {\n        if (priority == this.reservePriority) {\n            this.reservePriority = 0;\n        }\n        this.currentPriority = priority;\n        return this.startMotion(motion, false);\n    }\n}\nclass L2DPhysics {\n    constructor() {\n        this.physicsList = [];\n        this.startTimeMSec = UtSystem.getUserTimeMSec();\n    }\n    static load(buf) {\n        const ret = new L2DPhysics();\n        const pm = Live2DFramework.getPlatformManager();\n        const json = pm.jsonParseFromBytes(buf);\n        const params = json.physics_hair;\n        const paramNum = params.length;\n        for (let i = 0; i < paramNum; i++) {\n            const param = params[i];\n            const physics = new PhysicsHair();\n            const setup = param.setup;\n            const length = parseFloat(setup.length);\n            const resist = parseFloat(setup.regist);\n            const mass = parseFloat(setup.mass);\n            physics.setup(length, resist, mass);\n            const srcList = param.src;\n            const srcNum = srcList.length;\n            for (let j = 0; j < srcNum; j++) {\n                const src = srcList[j];\n                let id = src.id;\n                let type = PhysicsHair.Src.SRC_TO_X;\n                let typeStr = src.ptype;\n                if (typeStr === 'x') {\n                    type = PhysicsHair.Src.SRC_TO_X;\n                }\n                else if (typeStr === 'y') {\n                    type = PhysicsHair.Src.SRC_TO_Y;\n                }\n                else if (typeStr === 'angle') {\n                    type = PhysicsHair.Src.SRC_TO_G_ANGLE;\n                }\n                else {\n                    UtDebug.error('live2d', 'Invalid parameter:PhysicsHair.Src');\n                }\n                let scale = parseFloat(src.scale);\n                let weight = parseFloat(src.weight);\n                physics.addSrcParam(type, id, scale, weight);\n            }\n            const targetList = param.targets;\n            const targetNum = targetList.length;\n            for (let j = 0; j < targetNum; j++) {\n                const target = targetList[j];\n                let id = target.id;\n                let type = PhysicsHair.Target.TARGET_FROM_ANGLE;\n                let typeStr = target.ptype;\n                if (typeStr === 'angle') {\n                    type = PhysicsHair.Target.TARGET_FROM_ANGLE;\n                }\n                else if (typeStr === 'angle_v') {\n                    type = PhysicsHair.Target.TARGET_FROM_ANGLE_V;\n                }\n                else {\n                    UtDebug.error('live2d', 'Invalid parameter:PhysicsHair.Target');\n                }\n                let scale = parseFloat(target.scale);\n                let weight = parseFloat(target.weight);\n                physics.addTargetParam(type, id, scale, weight);\n            }\n            ret.physicsList.push(physics);\n        }\n        return ret;\n    }\n    updateParam(model) {\n        const timeMSec = UtSystem.getUserTimeMSec() - this.startTimeMSec;\n        for (let i = 0; i < this.physicsList.length; i++) {\n            this.physicsList[i].update(model, timeMSec);\n        }\n    }\n}\nclass L2DPose {\n    constructor() {\n        this.lastTime = 0;\n        this.lastModel = null;\n        this.partsGroups = [];\n    }\n    static load(buf) {\n        const ret = new L2DPose();\n        const pm = Live2DFramework.getPlatformManager();\n        const json = pm.jsonParseFromBytes(buf);\n        const poseListInfo = json.parts_visible;\n        const poseNum = poseListInfo.length;\n        for (let i_pose = 0; i_pose < poseNum; i_pose++) {\n            const poseInfo = poseListInfo[i_pose];\n            const idListInfo = poseInfo.group;\n            const idNum = idListInfo.length;\n            const partsGroup = [];\n            for (let i_group = 0; i_group < idNum; i_group++) {\n                const partsInfo = idListInfo[i_group];\n                const parts = new L2DPartsParam(partsInfo.id);\n                partsGroup[i_group] = parts;\n                if (partsInfo.link == null)\n                    continue;\n                const linkListInfo = partsInfo.link;\n                const linkNum = linkListInfo.length;\n                parts.link = [];\n                for (let i_link = 0; i_link < linkNum; i_link++) {\n                    const linkParts = new L2DPartsParam(linkListInfo[i_link]);\n                    parts.link.push(linkParts);\n                }\n            }\n            ret.partsGroups.push(partsGroup);\n        }\n        return ret;\n    }\n    updateParam(model) {\n        if (model == null)\n            return;\n        if (!(model == this.lastModel)) {\n            this.initParam(model);\n        }\n        this.lastModel = model;\n        const curTime = UtSystem.getUserTimeMSec();\n        let deltaTimeSec = this.lastTime == 0 ? 0 : (curTime - this.lastTime) / 1000.0;\n        this.lastTime = curTime;\n        if (deltaTimeSec < 0)\n            deltaTimeSec = 0;\n        for (let i = 0; i < this.partsGroups.length; i++) {\n            this.normalizePartsOpacityGroup(model, this.partsGroups[i], deltaTimeSec);\n            this.copyOpacityOtherParts(model, this.partsGroups[i]);\n        }\n    }\n    initParam(model) {\n        if (model == null)\n            return;\n        for (let i = 0; i < this.partsGroups.length; i++) {\n            const partsGroup = this.partsGroups[i];\n            for (let j = 0; j < partsGroup.length; j++) {\n                partsGroup[j].initIndex(model);\n                const partsIndex = partsGroup[j].partsIndex;\n                const paramIndex = partsGroup[j].paramIndex;\n                if (partsIndex < 0)\n                    continue;\n                const v = model.getParamFloat(paramIndex) != 0;\n                model.setPartsOpacity(partsIndex, v ? 1.0 : 0.0);\n                model.setParamFloat(paramIndex, v ? 1.0 : 0.0);\n                if (partsGroup[j].link == null)\n                    continue;\n                for (let k = 0; k < partsGroup[j].link.length; k++) {\n                    partsGroup[j].link[k].initIndex(model);\n                }\n            }\n        }\n    }\n    normalizePartsOpacityGroup(model, partsGroup, deltaTimeSec) {\n        let visibleParts = -1;\n        let visibleOpacity = 1.0;\n        const CLEAR_TIME_SEC = 0.5;\n        const phi = 0.5;\n        const maxBackOpacity = 0.15;\n        for (let i = 0; i < partsGroup.length; i++) {\n            let partsIndex = partsGroup[i].partsIndex;\n            const paramIndex = partsGroup[i].paramIndex;\n            if (partsIndex < 0)\n                continue;\n            if (model.getParamFloat(paramIndex) != 0) {\n                if (visibleParts >= 0) {\n                    break;\n                }\n                visibleParts = i;\n                visibleOpacity = model.getPartsOpacity(partsIndex);\n                visibleOpacity += deltaTimeSec / CLEAR_TIME_SEC;\n                if (visibleOpacity > 1) {\n                    visibleOpacity = 1;\n                }\n            }\n        }\n        if (visibleParts < 0) {\n            visibleParts = 0;\n            visibleOpacity = 1;\n        }\n        for (let i = 0; i < partsGroup.length; i++) {\n            let partsIndex = partsGroup[i].partsIndex;\n            if (partsIndex < 0)\n                continue;\n            if (visibleParts == i) {\n                model.setPartsOpacity(partsIndex, visibleOpacity);\n            }\n            else {\n                let opacity = model.getPartsOpacity(partsIndex);\n                let a1;\n                if (visibleOpacity < phi) {\n                    a1 = (visibleOpacity * (phi - 1)) / phi + 1;\n                }\n                else {\n                    a1 = ((1 - visibleOpacity) * phi) / (1 - phi);\n                }\n                const backOp = (1 - a1) * (1 - visibleOpacity);\n                if (backOp > maxBackOpacity) {\n                    a1 = 1 - maxBackOpacity / (1 - visibleOpacity);\n                }\n                if (opacity > a1) {\n                    opacity = a1;\n                }\n                model.setPartsOpacity(partsIndex, opacity);\n            }\n        }\n    }\n    copyOpacityOtherParts(model, partsGroup) {\n        for (let i_group = 0; i_group < partsGroup.length; i_group++) {\n            const partsParam = partsGroup[i_group];\n            if (partsParam.link == null)\n                continue;\n            if (partsParam.partsIndex < 0)\n                continue;\n            const opacity = model.getPartsOpacity(partsParam.partsIndex);\n            for (let i_link = 0; i_link < partsParam.link.length; i_link++) {\n                const linkParts = partsParam.link[i_link];\n                if (linkParts.partsIndex < 0)\n                    continue;\n                model.setPartsOpacity(linkParts.partsIndex, opacity);\n            }\n        }\n    }\n}\nclass L2DPartsParam {\n    constructor(id) {\n        this.paramIndex = -1;\n        this.partsIndex = -1;\n        this.link = null;\n        this.id = id;\n    }\n    initIndex(model) {\n        this.paramIndex = model.getParamIndex('VISIBLE:' + this.id);\n        this.partsIndex = model.getPartsDataIndex(PartsDataID.getID(this.id));\n        model.setParamFloat(this.paramIndex, 1);\n    }\n}\nclass L2DTargetPoint {\n    constructor() {\n        this.EPSILON = 0.01;\n        this.faceTargetX = 0;\n        this.faceTargetY = 0;\n        this.faceX = 0;\n        this.faceY = 0;\n        this.faceVX = 0;\n        this.faceVY = 0;\n        this.lastTimeSec = 0;\n    }\n    setPoint(x, y) {\n        this.faceTargetX = x;\n        this.faceTargetY = y;\n    }\n    getX() {\n        return this.faceX;\n    }\n    getY() {\n        return this.faceY;\n    }\n    update() {\n        const TIME_TO_MAX_SPEED = 0.15;\n        const FACE_PARAM_MAX_V = 40.0 / 7.5;\n        const MAX_V = FACE_PARAM_MAX_V / L2DTargetPoint.FRAME_RATE;\n        if (this.lastTimeSec == 0) {\n            this.lastTimeSec = UtSystem.getUserTimeMSec();\n            return;\n        }\n        const curTimeSec = UtSystem.getUserTimeMSec();\n        const deltaTimeWeight = ((curTimeSec - this.lastTimeSec) * L2DTargetPoint.FRAME_RATE) / 1000.0;\n        this.lastTimeSec = curTimeSec;\n        const FRAME_TO_MAX_SPEED = TIME_TO_MAX_SPEED * L2DTargetPoint.FRAME_RATE;\n        const MAX_A = (deltaTimeWeight * MAX_V) / FRAME_TO_MAX_SPEED;\n        const dx = this.faceTargetX - this.faceX;\n        const dy = this.faceTargetY - this.faceY;\n        if (Math.abs(dx) <= this.EPSILON && Math.abs(dy) <= this.EPSILON)\n            return;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        const vx = (MAX_V * dx) / d;\n        const vy = (MAX_V * dy) / d;\n        let ax = vx - this.faceVX;\n        let ay = vy - this.faceVY;\n        let a = Math.sqrt(ax * ax + ay * ay);\n        if (a < -MAX_A || a > MAX_A) {\n            ax *= MAX_A / a;\n            ay *= MAX_A / a;\n            a = MAX_A;\n        }\n        this.faceVX += ax;\n        this.faceVY += ay;\n        {\n            const max_v = 0.5 *\n                (Math.sqrt(MAX_A * MAX_A + 16 * MAX_A * d - 8 * MAX_A * d) - MAX_A);\n            const cur_v = Math.sqrt(this.faceVX * this.faceVX + this.faceVY * this.faceVY);\n            if (cur_v > max_v) {\n                this.faceVX *= max_v / cur_v;\n                this.faceVY *= max_v / cur_v;\n            }\n        }\n        this.faceX += this.faceVX;\n        this.faceY += this.faceVY;\n    }\n}\nL2DTargetPoint.FRAME_RATE = 30;\nclass L2DViewMatrix extends L2DMatrix44 {\n    constructor() {\n        super();\n        this.screenLeft = null;\n        this.screenRight = null;\n        this.screenTop = null;\n        this.screenBottom = null;\n        this.maxLeft = null;\n        this.maxRight = null;\n        this.maxTop = null;\n        this.maxBottom = null;\n        this.max = Number.MAX_VALUE;\n        this.min = 0;\n    }\n    getMaxScale() {\n        return this.max;\n    }\n    getMinScale() {\n        return this.min;\n    }\n    setMaxScale(v) {\n        this.max = v;\n    }\n    setMinScale(v) {\n        this.min = v;\n    }\n    isMaxScale() {\n        return this.getScaleX() == this.max;\n    }\n    isMinScale() {\n        return this.getScaleX() == this.min;\n    }\n    adjustTranslate(shiftX, shiftY) {\n        if (this.tr[0] * this.maxLeft + (this.tr[12] + shiftX) > this.screenLeft)\n            shiftX = this.screenLeft - this.tr[0] * this.maxLeft - this.tr[12];\n        if (this.tr[0] * this.maxRight + (this.tr[12] + shiftX) < this.screenRight)\n            shiftX = this.screenRight - this.tr[0] * this.maxRight - this.tr[12];\n        if (this.tr[5] * this.maxTop + (this.tr[13] + shiftY) < this.screenTop)\n            shiftY = this.screenTop - this.tr[5] * this.maxTop - this.tr[13];\n        if (this.tr[5] * this.maxBottom + (this.tr[13] + shiftY) >\n            this.screenBottom)\n            shiftY = this.screenBottom - this.tr[5] * this.maxBottom - this.tr[13];\n        const tr1 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, shiftX, shiftY, 0, 1];\n        L2DMatrix44.mul(tr1, this.tr, this.tr);\n    }\n    adjustScale(cx, cy, scale) {\n        const targetScale = scale * this.tr[0];\n        if (targetScale < this.min) {\n            if (this.tr[0] > 0)\n                scale = this.min / this.tr[0];\n        }\n        else if (targetScale > this.max) {\n            if (this.tr[0] > 0)\n                scale = this.max / this.tr[0];\n        }\n        const tr1 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1];\n        const tr2 = [scale, 0, 0, 0, 0, scale, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n        const tr3 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -cx, -cy, 0, 1];\n        L2DMatrix44.mul(tr3, this.tr, this.tr);\n        L2DMatrix44.mul(tr2, this.tr, this.tr);\n        L2DMatrix44.mul(tr1, this.tr, this.tr);\n    }\n    setScreenRect(left, right, bottom, top) {\n        this.screenLeft = left;\n        this.screenRight = right;\n        this.screenTop = top;\n        this.screenBottom = bottom;\n    }\n    setMaxScreenRect(left, right, bottom, top) {\n        this.maxLeft = left;\n        this.maxRight = right;\n        this.maxTop = top;\n        this.maxBottom = bottom;\n    }\n    getScreenLeft() {\n        return this.screenLeft;\n    }\n    getScreenRight() {\n        return this.screenRight;\n    }\n    getScreenBottom() {\n        return this.screenBottom;\n    }\n    getScreenTop() {\n        return this.screenTop;\n    }\n    getMaxLeft() {\n        return this.maxLeft;\n    }\n    getMaxRight() {\n        return this.maxRight;\n    }\n    getMaxBottom() {\n        return this.maxBottom;\n    }\n    getMaxTop() {\n        return this.maxTop;\n    }\n}\nclass Live2DFramework {\n    static getPlatformManager() {\n        return Live2DFramework.platformManager;\n    }\n    static setPlatformManager(platformManager) {\n        Live2DFramework.platformManager = platformManager;\n    }\n}\nLive2DFramework.platformManager = null;\nexport { L2DBaseModel, L2DViewMatrix, L2DEyeBlink, Live2DFramework, L2DMatrix44, L2DTargetPoint };\n","count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"toc":"","data":[]}